###### 认识哈希表

---

- 哈希表是一种非常重要的数据结构, 几乎所有的编程语言都有直接或者间接的应用这种数据结构
- 哈希表通常是基于数组进行实现的, 但是相对于数组, 它也很多的优势:
  - 插入,删除,查找速度很快,时间复杂度 O(1)
  - 哈希表相对于树的编码来说相对简单
- 相对于数组的不足
  - 哈希表的数据是没有数据的,所以不能按照固定的顺序进行遍历
  - 哈希表中的 key 是不允许重复的, 不能放置相同的 key, 用于保存不同的元素
- 哈希表的结构就是数组,但是他可以对下标进行变换,这种变换叫做哈希函数,通过哈希函数获取到 HashCode

为了把字符串转换为对应的下标值,有以下两种方案

- 数字相加,例如将字母转换成 unicode 码在进行相加,但是会存在转换之后,下标重复的问题
- 幂的连乘,`cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337 ,这个方法可以保证唯一性,但是较长的字符表示的数字非常大,会造成内存空间的浪费`

###### 哈希表的一些概念

- 哈希化:将大数字转换成数组范围内下标的过程
- 哈希函数,将单词转换成大数字,大数字进行哈希化的代码实现放在一个函数中就是哈希函数
- 哈希表:最终数据插入的数组进行整个结构的封装，得到的就是哈希表

###### 地址的冲突

在经过哈希函数哈希化之后,下标值仍有可能会发生冲突,解决冲突主要有两种方式:链地址法,开放地址法

- 链地址法:数组的每一个下标对应的位置位置存储不再是一个数字,而是经过哈希化之后,由相同下标组成数组或者链表
- 开放地址法:寻找空白的单元格来放置冲突的数据项,寻找空白单元格主要有以下三种方法
  - 线性探测:会线性的去查找空白的单元格,因此可能会遇到聚集问题(连续的一大段单元都无法插入),使性能下降
  - 二次探测:在线性探测的基础上优化了一下,线性探测的步长是 1,二次探测的步长是二次幂增加的,在极端情况下仍然会出聚集问题
  - 再哈希法:每一个关键字生成的探测步长不同,而不是每个关键词步长都一致,这样即使不同的关键词映射到同一个下标,也可以使用不同的步长

###### 装填因子

- 表示当前哈希表中已经包含的数据项和整个哈希表长度的比值
- 装填因子= 总数据项 / 哈希表长度
- 开放地址法的装填因子最大为 1，因为只有空白的单元才能放入元素
- 链地址法的装填因子可以大于 1，因为只要愿意，数组可以无限延伸下去

###### 哈希函数

哈希函数的优势在于速度,所以哈希函数不能使用性能消耗太大的复杂算法,提高算法速度的关键是尽量减少使用乘法和除法,性能高的哈希函数具备以下两个优点:

- 快速的计算
  霍纳法则:可以将多项式转化为嵌套形式，从而减少乘法和加法的次数，提高计算效率。霍纳法则的基本思想是：将多项式变形为一个嵌套的形式，每次只需要进行一次乘法和一次加法运算即可求出多项式的值。这种方法的时间复杂度为 O(n)，比直接计算多项式值的时间复杂度 O(n^2)要快得多
- 均匀的分布在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：链地址法或者开放地址法。但是，为了提供效率，最好的情况还是让数据在哈希表中均匀分布。因此，我们需要在使用常量的地方，尽量使用质数。比如：哈希表的长度、N 次幂的底数等。

###### 哈希表的扩容和压缩

- 在装填因子大于 0.75 的时候需要对哈希表进行扩容,同时扩容之后的哈希表容量仍应该是质数
